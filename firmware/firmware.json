{"title":"Silvia","content":"\/\/ This #include statement was automatically added by the Particle IDE.\n#include \"cloud_storage.h\"\n\n\/\/ Non-volatile storage\n#include \"storage.h\"\n#include \"helpers.h\"\n\n\/\/ Bubble display\n#include \"retro_led.h\"\n#include \"ht16k33.h\"\n\n\/\/ Thermocouple amplifier\n#include \"MAX6675.h\"\n\n\/\/ For resetting the I2C bus\n#include \"i2c_hal.h\"\n\nSYSTEM_MODE(SEMI_AUTOMATIC);\n\nbool temperatureValid = false;\ndouble temperature = 0;\ndouble relayDc = 0;\nchar cals[64] = \"\";\n\nMAX6675 thermo(SCK, SS, MISO);\n\nconst int RELAY_PIN = D5;\nconst int RELAY_POWER_PIN = D6;\nconst int RELAY_PERIOD_MILLIS = 1000;\n\nconst int EXTERNAL_LED_PIN = D3;\n\nRetroLED display;\n\nStorage storage;\n\nvoid setup() {\n    setupExternalLED();\n    setupStorage();\n    setupCloud();\n    setupRelay();\n    setupDisplay();\n}\n\nvoid setupExternalLED() {\n    set_rgb_led_change_handler(externalLEDHandler, NULL);\n    pinMode(EXTERNAL_LED_PIN, OUTPUT);\n}\n\nvoid setupStorage() {\n    storage.read();\n}\n\nvoid setupCloud() {\n    Spark.connect();\n    Spark.variable(\"temp\", &temperature, DOUBLE);\n    Spark.variable(\"dc\", &relayDc, DOUBLE);\n    Spark.variable(\"cals\", &cals, STRING);\n    Spark.function(\"rssi\", rssi);\n    \n    cloudStorage.setup(&storage);    \n}\n\nint rssi(String arg) {\n    return WiFi.RSSI();\n}\n\nint setCal(String arg) {\n    return 0;\n}\n\nvoid setupRelay() {\n    pinMode(RELAY_POWER_PIN, OUTPUT);\n    pinMode(RELAY_PIN, OUTPUT);\n    digitalWrite(RELAY_POWER_PIN, HIGH);\n    digitalWrite(RELAY_PIN, HIGH);\n}\n\nvoid setupDisplay() {\n    display.begin();\n}\n\nvoid loop() {\n    resetDisplay();\n    if(storage.getSleep() == 1) {\n        processSleep();\n    } else {\n        readTemperature();\n        controlTemperature();\n    }\n    publishData();\n    updateCals();\n    controlRelayByDelay();\n}\n\nvoid resetDisplay() {\n    HAL_I2C_End();\n    delay(1);\n    HAL_I2C_Begin(I2C_MODE_MASTER, 0x00);\n    \n}\n\nconst double temperatureCalibration = -2.0;\n\nvoid readTemperature() {\n    double readTemperature = thermo.readCelsius();\n    if(readTemperature == 0.0) {\n        temperatureValid = false;\n        display.printDashes();\n    } else {\n        temperatureValid = true;\n        temperature = thermo.readCelsius() + temperatureCalibration;\n        display.print(temperature);\n    }\n}\n\ninline double limit(double value, double min, double max) {\n    if(value < min) {\n        return min;\n    } else if(value > max) {\n        return max;\n    } else {\n        return value;\n    }\n}\n\ndouble error = 0;\ndouble pTerm = 0;\ndouble iTerm = 0;\nconst double iTermSaturation = 10; \/* Integral anti-windup *\/\nconst double integralErrorBand = 10; \/* Don't compute integral outside this band *\/\n\nvoid controlTemperature() {\n    if(!temperatureValid) {\n        relayDc = 0;\n        return;\n    }\n    \n    error = storage.getTargetTemperature() - temperature;\n    pTerm = storage.getKp() * error;\n    \n    double band = storage.getIntegralErrorBand();\n    if(error < band && error > -band) {\n        double sat = storage.getiTermSaturation();\n        iTerm = limit(storage.getKi() * error + iTerm, -sat, sat);\n    }\n    relayDc = limit(pTerm + iTerm + storage.getKo(), 0, 100);\n}\n\nvoid publishData() {\n    if(Spark.connected()) {\n        Spark.publish(\"coffee\", \"{\"\n            \"\\\"temp\\\":\" + String(temperature, 1) + \",\"\n            \"\\\"dc\\\":\" + String(relayDc, 1) + \",\"\n            \"\\\"e\\\":\" + String(error, 1) + \",\"\n            \"\\\"p\\\":\" + String(pTerm, 1) + \",\"\n            \"\\\"i\\\":\" + String(iTerm, 1) + \",\"\n            \"\\\"s\\\":\" + String(storage.getSleep(), 0)\n            + \"}\", 60, PRIVATE);\n    }\n}\n\nvoid updateCals() {\n    String calsValue = String(\"{\") +\n            \"\\\"sp\\\":\" + String(storage.getTargetTemperature(), 1) + \",\"\n            \"\\\"Kp\\\":\" + String(storage.getKp(), 1) + \",\"\n            \"\\\"Ki\\\":\" + String(storage.getKi(), 3) + \",\"\n            \"\\\"Ko\\\":\" + String(storage.getKo(), 1) + \",\"\n            \"\\\"iSat\\\":\" + String(storage.getiTermSaturation(), 1)\n            + \"}\";\n\n  \/\/ Set global char array\n  calsValue.toCharArray(cals, countof(cals));\n}\n\nvoid controlRelayByDelay() {\n    unsigned long start = millis();\n    const unsigned int period = 1000; \/* ms *\/\n    unsigned int dc = (unsigned int)(relayDc * period \/ 100.0);\n    if(dc > 0) {\n        digitalWrite(RELAY_PIN, LOW);\n        display.setLastDot(true);\n    }\n    bool high = false;\n    while(millis() - start < period) {\n        if(!high && millis() - start >= dc) {\n            digitalWrite(RELAY_PIN, HIGH);\n            display.setLastDot(false);\n            high = true;\n        }\n        \/\/ Process Wi-Fi messages\n        #ifndef PLATFORM_ID\n        SPARK_WLAN_Loop();\n        #else\n        Spark.process();\n        #endif\n        delayMicroseconds(1000); \/* 1ms *\/\n    }\n}\n\nvoid processSleep() {\n    display.printDodo();\n    if(Time.now() > (int)storage.getTwakeup()) {\n        storage.setSleep(0);\n    }\n    \n    relayDc = 0;\n}\n\n\n\/\/ Mirror green LED to external LED\nvoid externalLEDHandler(void* data, uint8_t r, uint8_t g, uint8_t b, void* reserved) {\n    analogWrite(EXTERNAL_LED_PIN, g);\n}\n","description":null,"id":"557ce7e8280b82e00b000627","tabs":[{"title":"MAX6675","content":"\/\/ this library is public domain. enjoy!\n\/\/ www.ladyada.net\/learn\/sensors\/thermocouple\n\n\n#include <application.h>\n\nclass MAX6675 {\n public:\n  MAX6675(int8_t SCLK_PIN, int8_t CS_PIN, int8_t MISO_PIN);\n\n  double readCelsius(void);\n  double readFarenheit(void);\n private:\n  static const int16_t pinDelay;\n\n  int8_t sclk, miso, cs;\n  byte spiread(void);\n};\n","extension":"h","id":"55c026d8187086b16d001508"},{"title":"MAX6675","content":"\/\/ this library is public domain. enjoy!\n\/\/ www.ladyada.net\/learn\/sensors\/thermocouple\n\n\n#include \"MAX6675.h\"\n\nconst int16_t MAX6675::pinDelay = 10;\n\nMAX6675::MAX6675(int8_t SCLK_PIN, int8_t CS_PIN, int8_t MISO_PIN) {\n  sclk = SCLK_PIN;\n  cs = CS_PIN;\n  miso = MISO_PIN;\n\n  \/\/define pin modes\n  pinMode(cs, OUTPUT);\n  pinMode(sclk, OUTPUT); \n  pinMode(miso, INPUT);\n\n  digitalWrite(cs, HIGH);\n}\ndouble MAX6675::readCelsius(void) {\n\n  uint16_t v;\n\n  digitalWrite(cs, LOW);\n  delayMicroseconds(pinDelay);\n\n  v = spiread();\n  v <<= 8;\n  v |= spiread();\n\n  digitalWrite(cs, HIGH);\n\n  if (v & 0x4) {\n    \/\/ uh oh, no thermocouple attached!\n    return 0; \n    \/\/return -100;\n  }\n\n  v >>= 3;\n\n  return v*0.25;\n}\n\ndouble MAX6675::readFarenheit(void) {\n  return readCelsius() * 9.0\/5.0 + 32;\n}\n\nbyte MAX6675::spiread(void) { \n  int i;\n  byte d = 0;\n\n  for (i=7; i>=0; i--)\n  {\n    digitalWrite(sclk, LOW);\n    delayMicroseconds(pinDelay);\n    if (digitalRead(miso)) {\n      \/\/set the bit to 0 no matter what\n      d |= (1 << i);\n    }\n\n    digitalWrite(sclk, HIGH);\n    delayMicroseconds(pinDelay);\n  }\n\n  return d;\n}\n","extension":"cpp","id":"55c026d8187086b16d001509"},{"title":"retro_led","content":"#ifndef __RETRO_LED_H__\n#define __RETRO_LED_H__\n\n#include \"application.h\"\n#include \"ht16k33.h\"\n\nclass RetroLED {\n    public:\n    \n    void begin(uint8_t deviceNumber = 0);\n\n    void print(float number);\n    void printDashes();\n    void printDodo();\n    void setLastDot(bool lastDot);\n    \n    private:\n    \n    void refreshDisplay();\n    \n    static const uint8_t DIGIT_MAPPING[4];\n    static const uint8_t NUMBER_CODES[10];\n    static const uint8_t DECIMAL_POINT_CODE;\n    static const uint8_t DASH_CODE;\n    static const uint8_t DODO_CODES[4];\n    \n    HT16K33 driver;\n\n    uint8_t digits[4];\n    boolean lastDot;\n};\n\n#endif \/\/ __RETRO_LED_H__\n","extension":"h","id":"55c026d8187086b16d00150a"},{"title":"retro_led","content":"#include \"retro_led.h\"\n\n\/* 7 seg bit positions\n   --   33\n  |  | 5  4\n   --   77\n  |  | 2  0\n   --   66\n*\/\n\nconst uint8_t RetroLED::DIGIT_MAPPING[4] = { 4, 6, 2, 0 };\nconst uint8_t RetroLED::NUMBER_CODES[10] = {\n    0x7D, \/\/ 0\n    0x11, \/\/ 1\n    0xDC, \/\/ 2\n    0xD9, \/\/ 3\n    0xB1, \/\/ 4\n    0xE9, \/\/ 5\n    0xED, \/\/ 6\n    0x19, \/\/ 7\n    0xFD, \/\/ 8\n    0xF9, \/\/ 9\n};\n\nconst uint8_t RetroLED::DECIMAL_POINT_CODE = 0x02;\nconst uint8_t RetroLED::DASH_CODE = 0x80;\nconst uint8_t RetroLED::DODO_CODES[4] = { 0xD5, 0xC5, 0xD5, 0xC5 };\n\nvoid RetroLED::begin(uint8_t deviceNumber) {\n    this->driver.begin(deviceNumber);\n}\n\nvoid RetroLED::print(float number) {\n    this->driver.setBrightness();\n\n    \/\/ Don't bother with negative numbers right now\n    if(number < 0) {\n        number = 0;\n    } else if(number > 999.9) {\n        number = 999.9;\n    }\n    \n    \/\/ Print with a single decimal\n    \/\/ Round correctly\n    int wholeNumber = (int)((number * 10) + 0.5);\n\n    \/\/ Convert each digit to the correct number code\n    for(int i = 3; i >= 0; i--) {\n        uint8_t code;\n        \/\/ Don't show leading zeros\n        if(wholeNumber == 0 && i <= 1) {\n            code = 0;\n        } else {\n            code = NUMBER_CODES[wholeNumber % 10];\n        }\n        this->digits[i] = code;\n        wholeNumber \/= 10;\n    }\n\n    \/\/ Add decimal point to the 3rd digit\n    this->digits[2] |= DECIMAL_POINT_CODE;\n    \n    this->refreshDisplay();\n}\n\nvoid RetroLED::printDashes() {\n    this->driver.setBrightness();\n    for(int i = 0; i < 4; i++) {\n        this->digits[i] = DASH_CODE;\n    }\n    this->refreshDisplay();\n}\n\nvoid RetroLED::printDodo() {\n    this->driver.setBrightness(4);\n    for(int i = 0; i < 4; i++) {\n        this->digits[i] = DODO_CODES[i];\n    }\n    this->refreshDisplay();\n}\n\nvoid RetroLED::setLastDot(bool lastDot) {\n    this->lastDot = lastDot;\n    this->refreshDisplay();\n}\n\nvoid RetroLED::refreshDisplay() {\n    uint8_t driverDigits[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n    \n    for(int i = 0; i < 4; i++) {\n        driverDigits[DIGIT_MAPPING[i]] = this->digits[i];\n    }\n    \n    \/\/ Add last dot if enabled\n    driverDigits[DIGIT_MAPPING[3]] |= this->lastDot ? DECIMAL_POINT_CODE : 0;\n    \n    this->driver.writeDisplay(driverDigits, 0, 8);\n}\n","extension":"cpp","id":"55c026d8187086b16d00150b"},{"title":"ht16k33","content":"#ifndef __HT16K33_H__\n#define __HT16K33_H__\n\n#include \"application.h\"\n\nclass HT16K33 {\n    public:\n    \n    void begin(uint8_t deviceNumber = 0);\n    void setBrightness(uint8_t brightness = DEFAULT_BRIGHTNESS);\n    \n    static const uint8_t MAX_BRIGHTNESS;\n    static const uint8_t DEFAULT_BRIGHTNESS;\n    \n    \/\/ Low-level interface\n    \n    void writeCommand(uint8_t command);\n    \n    static const uint8_t COMMAND_ON;\n    static const uint8_t COMMAND_STANDBY;\n    static const uint8_t COMMAND_DISPLAY_ON;\n    static const uint8_t COMMAND_DISPLAY_OFF;\n    static const uint8_t COMMAND_BRIGHTNESS;\n    \n    void writeByte(uint8_t address, uint8_t data);\n    void writeDisplay(uint8_t data[], uint8_t start, uint8_t length);    \n\n    private:\n    \n    static const uint8_t BASE_SLAVE_ADDRESS;\n    uint8_t i2cAddress;\n    \n};\n\n\n#endif \/\/ __HT16K33_H__\n\n","extension":"h","id":"55c026d8187086b16d00150c"},{"title":"ht16k33","content":"#include \"ht16k33.h\"\n\nconst uint8_t HT16K33::BASE_SLAVE_ADDRESS = 0x70;\n\nconst uint8_t HT16K33::COMMAND_ON = 0x21;\nconst uint8_t HT16K33::COMMAND_STANDBY = 0x20;\n\nconst uint8_t HT16K33::COMMAND_DISPLAY_ON = 0x81;\nconst uint8_t HT16K33::COMMAND_DISPLAY_OFF = 0x80;\nconst uint8_t HT16K33::COMMAND_BRIGHTNESS = 0xE0;\n\nconst uint8_t HT16K33::MAX_BRIGHTNESS = 15;\nconst uint8_t HT16K33::DEFAULT_BRIGHTNESS = 8;\n\nvoid HT16K33::begin(uint8_t deviceNumber) {\n    \/\/ Allow chip to finish reset cycle\n    delay(1);\n\n    this->i2cAddress = BASE_SLAVE_ADDRESS + deviceNumber;\n    \n    Wire.begin();\n    \n    this->writeCommand(COMMAND_ON);\n    this->writeCommand(COMMAND_DISPLAY_ON);\n    this->setBrightness(DEFAULT_BRIGHTNESS);\n}\n\nvoid HT16K33::setBrightness(uint8_t brightness) {\n    if(brightness > MAX_BRIGHTNESS) {\n        brightness = MAX_BRIGHTNESS;\n    }\n    this->writeCommand(COMMAND_BRIGHTNESS + brightness);\n}\n\nvoid HT16K33::writeCommand(uint8_t command) {\n    Wire.beginTransmission(this->i2cAddress);\n    Wire.write(command);\n    Wire.endTransmission();\n}\n\n\nvoid HT16K33::writeByte(uint8_t address, uint8_t data) {\n    Wire.beginTransmission(this->i2cAddress);\n    Wire.write(address);\n    Wire.write(data);\n    Wire.endTransmission();\n}\n\nvoid HT16K33::writeDisplay(uint8_t data[], uint8_t start, uint8_t length) {\n    Wire.beginTransmission(this->i2cAddress);\n    Wire.write(start);\n    for(uint8_t i = 0; i < length; i++) {\n        Wire.write(data[i]);\n    }\n    Wire.endTransmission();\n}\n","extension":"cpp","id":"55c026d8187086b16d00150d"},{"title":"storage","content":"\/*\n * Non-volatile storage\n *\/\n\n#ifndef __STORAGE_H__\n#define __STORAGE_H__\n\nclass Storage {\n  public:\n    void read();\n\n    double getTargetTemperature();\n    double getKp();\n    double getKi();\n    double getKo();\n    double getiTermSaturation();\n    double getIntegralErrorBand();\n    double getSleep();\n    double getTwakeup();\n\n    void setTargetTemperature(double value);\n    void setKp(double value);\n    void setKi(double value);\n    void setKo(double value);\n    void setiTermSaturation(double value);\n    void setIntegralErrorBand(double value);\n    void setSleep(double value);\n    void setTwakeup(double value);\n\n  private:\n\n    void migrate();\n\n    unsigned int getVersion();\n    void setVersion(unsigned int value);\n\n    void save(int addr, unsigned int length);\n\n    \/* This struct must not be re-ordered since it is the EEPROM layout.\n     * Elements must not be deleted.\n     * To remove an element, replace the name by _unused1\/2\/3.\n     * Elements must only be added at the end.\n     *\/\n    struct Data {\n      unsigned int version;\n\n      double TargetTemperature;\n      double Kp;\n      double Ki;\n      double Ko;\n      double iTermSaturation;\n      double IntegralErrorBand;\n      double Sleep;\n      double Twakeup;\n    } data;\n\n    static const Data DEFAULT_DATA;\n};\n\n#endif \/\/ __STORAGE_H__\n","extension":"h","id":"55c026d8187086b16d00150e"},{"title":"storage","content":"\/*\n * Non-volatile storage for hour meter\n *\/\n\n#include \"storage.h\"\n#include \"helpers.h\"\n#include \"application.h\"\n\nconst Storage::Data Storage::DEFAULT_DATA = {\n  \/* version *\/ 1,\n  \/* TargetTemperature *\/ 96.0,\n  \/* Kp                *\/ 2.0,\n  \/* Ki                *\/ 0.01,\n  \/* Ko                *\/ 6.0,\n  \/* iTermSaturation   *\/ 10.0,\n  \/* IntegralErrorBand *\/ 10.0,\n  \/* Sleep             *\/ 0.0,\n  \/* Twakeup           *\/ 1436005800.0, \/* 6:30am EST *\/\n};\n\nvoid Storage::read() {\n  uint8_t *dataBytes = (uint8_t *)&this->data;\n  const unsigned int data_size = sizeof(Storage::Data);\n\n  for(int addr = 0; addr < (int)data_size; addr++) {\n    dataBytes[addr] = EEPROM.read(addr);\n  }\n\n  this->migrate();\n}\n\nvoid Storage::migrate() {\n  const unsigned int data_size = sizeof(Storage::Data);\n\n  while(this->getVersion() != Storage::DEFAULT_DATA.version) {\n    switch(this->getVersion()) {\n      case 0:\n        \/* Sleep and Twakeup added *\/\n        this->setSleep(Storage::DEFAULT_DATA.Sleep);\n        this->setTwakeup(Storage::DEFAULT_DATA.Twakeup);\n        this->setVersion(1);\n        break;\n\n      case 1:\n        \/* Current version *\/\n        break;\n\n      default:\n        \/* EEPROM was erased *\/\n        memcpy(&this->data, &Storage::DEFAULT_DATA, data_size);\n        save(0, data_size);\n        break;\n    }\n  }\n}\n\nvoid Storage::save(int addr, unsigned int length) {\n  uint8_t *dataBytes = (uint8_t *)&this->data;\n\n  for(; length > 0; addr++, length--) {\n    uint8_t byte = dataBytes[addr];\n    EEPROM.write(addr, byte);\n  }\n}\n\nunsigned int Storage::getVersion() {\n  return this->data.version;\n}\n\ndouble Storage::getTargetTemperature() {\n  return this->data.TargetTemperature;\n}\n\ndouble Storage::getKp() {\n  return this->data.Kp;\n}\n\ndouble Storage::getKi() {\n  return this->data.Ki;\n}\n\ndouble Storage::getKo() {\n  return this->data.Ko;\n}\n\ndouble Storage::getiTermSaturation() {\n  return this->data.iTermSaturation;\n}\n\ndouble Storage::getIntegralErrorBand() {\n  return this->data.IntegralErrorBand;\n}\n\ndouble Storage::getSleep() {\n  return this->data.Sleep;\n}\n\ndouble Storage::getTwakeup() {\n  return this->data.Twakeup;\n}\n\nvoid Storage::setVersion(unsigned int value) {\n  if(this->data.version != value) {\n    this->data.version = value;\n    save(offsetof_and_sizeof(Storage::Data, version));\n  }\n}\n\nvoid Storage::setTargetTemperature(double value) {\n  if(this->data.TargetTemperature != value) {\n    this->data.TargetTemperature = value;\n    save(offsetof_and_sizeof(Storage::Data, TargetTemperature));\n  }\n}\n\nvoid Storage::setKp(double value) {\n  if(this->data.Kp != value) {\n    this->data.Kp = value;\n    save(offsetof_and_sizeof(Storage::Data, Kp));\n  }\n}\n\nvoid Storage::setKi(double value) {\n  if(this->data.Ki != value) {\n    this->data.Ki = value;\n    save(offsetof_and_sizeof(Storage::Data, Ki));\n  }\n}\n\nvoid Storage::setKo(double value) {\n  if(this->data.Ko != value) {\n    this->data.Ko = value;\n    save(offsetof_and_sizeof(Storage::Data, Ko));\n  }\n}\n\nvoid Storage::setiTermSaturation(double value) {\n  if(this->data.iTermSaturation != value) {\n    this->data.iTermSaturation = value;\n    save(offsetof_and_sizeof(Storage::Data, iTermSaturation));\n  }\n}\n\nvoid Storage::setIntegralErrorBand(double value) {\n  if(this->data.IntegralErrorBand != value) {\n    this->data.IntegralErrorBand = value;\n    save(offsetof_and_sizeof(Storage::Data, IntegralErrorBand));\n  }\n}\n\nvoid Storage::setSleep(double value) {\n  if(this->data.Sleep != value) {\n    this->data.Sleep = value;\n    save(offsetof_and_sizeof(Storage::Data, Sleep));\n  }\n}\n\nvoid Storage::setTwakeup(double value) {\n  if(this->data.Twakeup != value) {\n    this->data.Twakeup = value;\n    save(offsetof_and_sizeof(Storage::Data, Twakeup));\n  }\n}","extension":"cpp","id":"55c026d8187086b16d00150f"},{"title":"helpers","content":"#ifndef __HELPERS_H__\n#define __HELPERS_H__\n\n\/* Sizeof for a struct member *\/\n#define member_sizeof(T,F) sizeof(((T *)0)->F)\n\n\/* Offset and size of a struct member as 2 arguments *\/\n#define offsetof_and_sizeof(T, F) offsetof(T, F), member_sizeof(T, F)\n\n\/* Number of elements in static array *\/\n#define countof(arr) sizeof(arr) \/ sizeof(arr[0])\n\n#endif \/* __HELPERS_H__ *\/\n","extension":"h","id":"55c026d8187086b16d001510"},{"title":"cloud_storage","content":"\/\/ Set and get storage values through the cloud\n\n#ifndef __CLOUD_STORAGE_H__\n#define __CLOUD_STORAGE_H__\n\n#include \"application.h\"\n#include \"storage.h\"\n\nclass CloudStorage {\n  public:\n  void setup(Storage *storage);\n\n  \/\/ Should only be called by cloudSet and cloudGet\n  int set(String assignment);\n  int get(String name);\n\n  private:\n\n  void setResult(String value);\n\n  typedef void(Storage::*SetDoubleMethod)(double);\n  typedef double(Storage::*GetDoubleMethod)();\n\n  struct CloudStorageMethod {\n    String name;\n    SetDoubleMethod setDouble;\n    GetDoubleMethod getDouble;\n  };\n\n  static const CloudStorageMethod cloudStorageMethods[];\n\n  const CloudStorageMethod *csmByName(String name);\n\n  Storage *storage;\n};\n\n\/\/ Singleton instance\nextern CloudStorage cloudStorage;\n\n#endif \/\/ __CLOUD_STORAGE_H__\n","extension":"h","id":"55c026d8187086b16d001511"},{"title":"cloud_storage","content":"\/\/ Set and get storage values through the cloud\n\n#include \"cloud_storage.h\"\n#include \"helpers.h\"\n\nconst CloudStorage::CloudStorageMethod CloudStorage::cloudStorageMethods[] = {\n  { \"sp\", &Storage::setTargetTemperature, &Storage::getTargetTemperature },\n  { \"Kp\", &Storage::setKp, &Storage::getKp },\n  { \"Ki\", &Storage::setKi, &Storage::getKi },\n  { \"Ko\", &Storage::setKo, &Storage::getKo },\n  { \"iSat\", &Storage::setiTermSaturation, &Storage::getiTermSaturation },\n  { \"iBand\", &Storage::setIntegralErrorBand, &Storage::getIntegralErrorBand },\n  { \"sleep\", &Storage::setSleep, &Storage::getSleep },\n  { \"Twakeup\", &Storage::setTwakeup, &Storage::getTwakeup },\n};\n\n\/\/ Singleton instance\nCloudStorage cloudStorage;\n\n\/\/ Spark.function and Spark.variable expect globals.\n\/\/ Static at least restricts them to this file.\nstatic int cloudSet(String value) {\n  return cloudStorage.set(value);\n}\nstatic int cloudGet(String value) {\n  return cloudStorage.get(value);\n}\nstatic char getResult[64];\n\nvoid CloudStorage::setup(Storage *storage) {\n  this->storage = storage;\n\n  Spark.function(\"set\", cloudSet);\n  Spark.function(\"get\", cloudGet);\n  Spark.variable(\"result\", getResult, STRING);\n}\n\nint CloudStorage::set(String assignment) {\n  int equalSign = assignment.indexOf(\"=\");\n  if(equalSign >= 0) {\n    String name = assignment.substring(0, equalSign);\n    String value = assignment.substring(equalSign + 1);\n\n    const CloudStorageMethod *csm = csmByName(name);\n    if(csm) {\n      if(csm->setDouble) {\n        \/\/ Call method on storage object\n        (storage->*(csm->setDouble))(value.toFloat());\n        return 0;\n      } else {\n        return -3; \/* Nothing defined?!? *\/\n      }\n    } else {\n      return -2; \/* Variable name not found *\/\n    }\n  } else {\n    return -1; \/* Wrong format *\/\n  }\n}\n\nint CloudStorage::get(String name) {\n  const CloudStorageMethod *csm = csmByName(name);\n  if(csm) {\n    if(csm->getDouble) {\n      \/\/ Call method on storage object\n      double value = (storage->*(csm->getDouble))();\n      int precision;\n      if(value > 1000000) {\n        precision = 0;\n      } else if(value > 1000) {\n        precision = 3;\n      } else {\n        precision = 6;\n      }\n      setResult(String(value, precision));\n      return 0;\n    } else {\n      return -3; \/* Nothing defined?!? *\/\n    }\n  } else {\n    return -2; \/* Variable name not found *\/\n  }\n}\n\nconst CloudStorage::CloudStorageMethod *CloudStorage::csmByName(String name) {\n  for(unsigned int i = 0; i < countof(cloudStorageMethods); i++) {\n    const CloudStorageMethod *csm = &cloudStorageMethods[i];\n    if(name.equals(csm->name)) {\n      return csm;\n    }\n  }\n  return NULL;\n}\n\nvoid CloudStorage::setResult(String value) {\n  \/\/ Set global char array\n  value.toCharArray(getResult, countof(getResult));\n}\n","extension":"cpp","id":"55c026d8187086b16d001512"}],"library_ids":[]}
